### 유형 : 그리디
### 윤기범
https://www.acmicpc.net/problem/1105

### 문제 접근 방식
  - 문제를 읽고 그리디로 판단함
  - L은 2,000,000,000보다 작거나 같은 자연수이고, R은 L보다 크거나 같고, 2,000,000,000보다 작거나 같은 자연수 이므로 단일 for문 사용
  - 기본적인 방법은 다음과 같다.
  - a보다 b가 무조건 더 크므로 a의 자리수를 b에 맞춘다. (앞에 부족한 자리수만큼 0을 붙이는 방식으로)
  ```java
  int tempNumber = b.length() - a.length(); // b길이에 a길이 맞추기
  for(int i = 0; i < tempNumber; i++) {
    a = "0" + a; // 앞에 0을 더하여 자리수 맞춤
  }
  ```
  - 그 후 b에 8이 존재하는 인덱스 값들을 ArrayList에 삽입한다.
  - 위의 과정이 끝나면 for문을 통해 ArrayList에서 하나씩 뽑아서 시작지점부터 해당 지점까지 조회한다.
    - 이때 시작지점은 초기는 0이며 그 후 부터는 직전 루프의 ArrayList에서 뽑은 값이다.
    - 이때 시작지점부터 뽑은 값 까지 조회를 하며 다른수가 하나라도 존재하면 그 이후부터는 8이 없는 수를 만들수 있다.
      - ex) 80808 81808 인 경우 첫번째 8부터 두번째 8 사이에 다른값 존재하고 81000 등으로 8이 필요없는 존재한다.
    - 이렇게 한번이라도 다른값이 나오면 그 이후부터는 flag를 조회하며 참 값을 가지므로 더이상 조회하지 않음 
  ```java
    for(int i = 0; i < arr.size(); i++) { 
      if(!check){
      loop: for(int j = start; j <= arr.get(i); j++) { // 시작지점부터 8이 존재하는 위치까지 조회
        if(a.charAt(j) != b.charAt(j)) { // 그 사이에 다른수가 하나라도 존재하면 무조건 8을 안쓸수 있으므로 이 경우는 세지 않는다.
          check = true;
          break loop;
        }
      } 
    }
    start = arr.get(i);
    if(!check) { // 위의 조건을 충족하지 않는것만 셈
      ans += 1;
    }
  }
  System.out.println(ans);
  ```
  
  
### 주의할 점
  - 특별하게 없음

### 보완할 점
  - 특별하게 없음
