## 유형 : DP
[2225: 합분해](https://www.acmicpc.net/problem/2225)

### 문제 접근 방식
  - K가 1인 경우는 자기 자신 밖에 없기 때문에 모두 1이다.
  - K=2부터 경우의 수를 나열해 본 결과, N을 K개로 나타낼 수 있는 경우의 수는 K-1개로 나타낸 0...N에 차례로 N...0을 뒤에 붙인 것과 같다.
  - 따라서 이를 배열로 나타내면, dp[K][N] = dp[K-1][0] + ... + dp[K-1][N]과 같다
<br></br>
  - K가 1인 경우 모두 1로 채운다
  - N이 0인 경우는 자기 자신만큼 0을 더한 1가지 경우 밖에 존재하지 않는다
  - 이전 배열의 값을 모두 더해 저장한다
``` Java
        long[][] dp = new long[K][N+1];
        Arrays.fill(dp[0], 1);
        
        for(int i=1; i<K; i++){
            dp[i][0] = 1;

            for(int j=1; j<=N; j++){
                for(int k=0; k<=j; k++){
                    dp[i][j] += dp[i-1][k];
                }
                dp[i][j] = dp[i][j]%1000000000;
            }
        }
```

### 주의할 점
  - dp 배열의 값을 1000000000으로 mod 연산하는 거 잊지 말기
  - dp배열의 값이 int가 넘어가게 되기 때문에 long으로 선언

### 부족한 점
  - 특별하게 없다
    
