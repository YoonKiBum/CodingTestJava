## 유형 : DP
[1520: 내리막 길](https://www.acmicpc.net/problem/1520)

### 문제 접근 방식
  - bfs로 문제를 해결하면 메모리 초과가 발생한다. 불필요한 경로를 탐색하는 경우가 많다는 의미이기 때문에 dp를 통해 해결한다.
  - 해당 문제에서 발생할 수 있는 불필요한 경로는, 공통되는 경로를 다시 탐색하는 경우이다. 따라서 출발 지점에서 도착 지점으로 가는 것이 아닌, 도착 지점에서 반대로 간다고 생각하면, 공통되는 경로를 재탐색 할 필요가 없어진다. 
  - 방문했지만, 경로가 없는 경우를 위해 초기값을 모두 -1로 설정한 뒤, 해당 지점에 대해 탐색을 시작할 때 값을 0으로 업데이트 한다.

  - 해당 지점에서 4방향에 대해 탐색하여 발생할 수 있는 모든 경로를 합친다
``` Java
        if(dp[row][col]==-1){
            dp[row][col] = 0;

            for(int i=0; i<4; i++){
                int nr = row + dr[i];
                int nc = col + dc[i];

                if(nr<0 || nr>=M || nc<0 || nc>=N)
                    continue;

                if(map[row][col]>map[nr][nc]){
                    dp[row][col] += dfs(nr, nc);
                }
            }
```

### 주의할 점
  - 

### 부족한 점
  - [BFS+DP](https://lovelyunsh.tistory.com/40)
  - 우선순위 큐를 이용하여 높이가 높은 순서대로 poll해야 한다 -> bfs를 통해 도착지점까지 탐색한 후 다음 분기를 탐색하게 되어 dfs와 다를 게 없다. 또한 겹치는 경로가 존재하면 겹치는 지점까지 이동한 후, 이동 경로의 수만큼 + 한 후 같이 이동하면 되는데, 숫자가 더 높은 다른 경로를 통해 이동하다, 해당 지점에서 만나 같이 이동할 수 있다. 즉, 경로가 합쳐지는 지점이 존재하면 다른 경로에서 해당 지점에 오기 전까지 기다린다.
  - 이미 처리되어 들어있는 값이 1 이상이면 큐에 넣지 않는다 -> 위의 설명에서와 마찬가지로, 겹치는 지점은 이미 큐에 들어가 있으며, 더 높은 숫자들로 이루어진 경로가 해당 지점에 오기까지 기다리는 상태이다. 더 높은 경로를 통해 해당 지점에 도착하면, 이미 큐에 다음 지점이 들어가 있는 상태이기 때문에 삽입할 필요가 없다. 
