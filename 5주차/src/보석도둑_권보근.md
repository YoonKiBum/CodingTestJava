## 유형 : 그리디
[1202: 보석도둑](https://www.acmicpc.net/problem/1202)

### 문제 접근 방식
  - 가방의 무게를 오름차순으로 정렬한 후, 들어갈 수 있는 보석 중에서 가장 높은 가치를 가진 보석을 선택해서 넣어야 한다.
  - 현재 선택된 가방에 들어갈 수 있는 보석을 선택하기 위해서, 보석은 무게에 대해 오름차순으로 정렬되어야 한다.
  - 가방에 들어갈 수 있는 보석들을 선별한 후, 해당 보석들 중 가장 높은 가치를 가진 보석을 선택해야 하기 때문에, 보석의 가치에 대해 내림차순으로 정렬한다.
  - 따라서 보석의 무게순으로 정렬한 자료구조, 보석의 가치순으로 정렬한 자료구조가 필요하다. 또한 보석이 선택된 후, 다음 단계의 가방에 대해서 선택된 보석 + 새로 선택된 보석에 대한 정렬이 필요하기 때문에, 삽입과 삭제가 빈번하게 일어나고 이후에 정렬에 대한 자료구조가 필요하기 때문에 우선순위 큐를 사용하여 해결한다.
  - 또한 가방의 개수는 300,000, 보석의 가치는 1,000,000까지 가능하기 때문에 가치의 합을 나타내기 위한 long 변수를 사용

  - 무게에 대해 오름차순 정렬(가방에 담을 수 있는 보석들 poll) / 가치에 대해 내림차순 정렬(가장 높은 가치의 보석 poll)
``` Java
        PriorityQueue<Node> p_w = new PriorityQueue<>((o1, o2) -> Integer.compare(o1.w, o2.w));
        PriorityQueue<Node> p_v = new PriorityQueue<>((o1, o2) -> Integer.compare(o2.v, o1.v));
```

  - 무게 순으로 정렬한 큐로부터 가방이 담을 수 있는 무게의 보석들을 선택 / 가장 가치가 높은 보석 선택
``` Java
        long ans = 0L;
        for(int i=0; i<bags.length; i++){
            while(!p_w.isEmpty()){
                Node cur = p_w.poll();

                if(cur.w > bags[i]) {
                    p_w.offer(cur);
                    break;
                }

                p_v.offer(cur);
            }

            if(!p_v.isEmpty()){
                ans += p_v.poll().v;
            }
        }
```

### 주의할 점
  - 처음에는 각 가방을 선택한 단계에서, 가방에 담을 수 있는 보석들을 선택하여 우선순위 큐에 삽입한 후, 가장 높은 우선순위의 보석을 제거하고 다시 무게순으로 정렬한 우선순위 큐에 남은 보석들을 삽입하여 재선택하였는데 시간 초과가 발생하였다. 보석이 선택된 후 남은 보석들은, 어차피 가방이 무게순으로 정렬되어 있기 때문에, 해당 보석들도 다음 단계에서 선택될 수 있는 보석들이다. 따라서 다시 뺄 필요가 없다.

### 부족한 점
  - 특별하게 없다
