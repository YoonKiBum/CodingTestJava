## 유형 : DP
[11053: 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

### 문제 접근 방식
  - 최장 증가 부분 수열(LIS): 주어진 수열에서 오름차순으로 구성 가능한 원소들을 선택하여 최대 길이를 찾아내는 것
  - 이중 반복문을 통해, dp[i]의 값을 업데이트 한다. dp[i]의 값은 0~N-1번째까지의 값을 모두 순회하여 갱신할 수 있다.

  - 해당 단계에 대한 dp의 값을 갱신하기 위해서 dp 값을 1로 초기화 / 값이 1인 경우 부분 수열의 시작점을 의미
``` Java
        for(int i=0; i<N; i++){
            seq[i] = Integer.parseInt(st.nextToken());
            dp[i] = 1;
```

  - swq[j]의 값보다 seq[i]의 값이 더 크다는 것은 해당 부분 수열의 집합에 seq[i] 값이 들어갈 수 있다는 의미
  - 집합에 들어갈 수 있는 경우, 해당 dp의 값이 dp[j]보다 크면 안된다. dp[j]의 값보다 dp[i]의 값이 크다는 것은 이미 소속된 부분 집합이 존재한다는 것을 의미
``` Java
            for(int j=0; j<i; j++){
                if(seq[j]<seq[i] && dp[i]<=dp[j])
                    dp[i] = dp[j]+1;
            }
```

### 주의할 점
  - dp[i]의 값이 dp[j]의 값 이하인 경우, 즉 아직 다른 부분 수열 집합에 해당 숫자가 들어가지 않은 경우를 위한 조건  

### 부족한 점
  - 이분탐색으로 해결하는 방법이 더 낮은 시간 복잡도를 갖기 때문에, 이분 탐색 학습 필
