## 유형 : DP
[1890: 점프](https://www.acmicpc.net/problem/1890)

### 문제 접근 방식
  - 처음에는 bfs로 생각하였으나, 메모리 초과 이슈가 발생했다. 또한 시작점과 모든 정점과의 최단 거리가 필요한 것이 아니기 때문에, dp를 통해 풀어야 한다.
  - dp 배열을 시작점부터 가능한 모든 점에 값을 업데이트 한다. 이때 업데이트 되는 값은 이전 정점의 값에 현재 정점의 값을 더한 값이다. 이는 해당 정점을 방문할 수 있는 경로의 수를 나타내게 된다. 
  - 따라서 해당 지점의 값이 1 이상인 경우, 해당 정점에 대해 다시 탐색하면 된다. 

  - 현재 정점의 값이 1 이상인 경우, 즉 방문 가능한 점점인 경우에 대해서면 탐색하여 다음 정점의 값을 업데이트 한다. 
``` Java
            for(int j=0; j<N; j++){
                int move = Integer.parseInt(st.nextToken());

                if(dp[i][j]>=1 && move!=0){
                    if(i+move<N)
                        dp[i+move][j] += dp[i][j];
                    if(j+move<N)
                        dp[i][j+move] += dp[i][j];
                }
            }
```

### 주의할 점
  - 숫자의 범위가 크기 때문에 integer로 나타낼 수 없는 경우가 존재한다. 따라서 long형의 배열을 생성해줘야 한다. 

### 부족한 점
  - 이런 문제와 같이 모든 정점을 탐색하며, 길을 찾는 경우가 아닌 문제는 dp를 활용하여 해결
